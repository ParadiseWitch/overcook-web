# 食材食物的烹饪组合设计以及相关模型设计

## 需求

实现类似胡闹厨房一样的食物烹饪状态和组合效果

- 实现多食材组合
  - 例如生菜番茄沙拉菜谱： 生菜/+番茄/
  切好的生菜、番茄可以组合在一起成为一道菜品
- 实现烹饪状态组合
  - 例如清蛋糕：《｛鸡蛋+面粉｝》
  鸡蛋和面粉要两个食材在一起搅拌好，并在煎锅里面烧好

## 思路

### 建立模型

#### 食材和食物

- 食材: 从食材箱取出，未经过烹饪和组合的物体。例如没有切的西红柿
- 食物：利用食材进行烹饪组合加工得到的产物。例如切过的西红柿，搅拌后的面粉和鸡蛋

##### 举例

以胡闹厨房菜单中的几个典型菜品为例：

1. **生菜番茄沙拉**（生菜/+番茄/）
   - 食材：生菜、番茄（从食材箱取出的原始状态）
   - 食物：切好的生菜、切好的番茄，以及它们组合成的沙拉

2. **清蛋糕**《｛鸡蛋+面粉｝》
   - 食材：鸡蛋、面粉
   - 食物：搅拌后的鸡蛋面粉混合物 -> 烤好的蛋糕

3. **鱼寿司**（鱼/+米*+紫菜）
   - 食材：鱼、米、紫菜
   - 食物：切好的鱼、煮好的米，以及它们与紫菜组合成的寿司

##### 伪代码

```ts
interface Ingredient {
  name: string;           // 食材标识，如：'tomato', 'egg', 'lettuce'
  displayName: string;    // 显示名称，如：'番茄', '鸡蛋', '生菜'
  homeStation: Station;   // 出生的工作站（食材箱）
  texture: string;        // 纹理资源路径
}

interface Food {
  components: (Food | Ingredient)[]; // 组成成分，支持嵌套（食材或已加工的食物）
  cookStates: CookState[];           // 经过的烹饪状态链，有序
  isCooking: boolean;                // 是否正在烹饪中
  progress: number;                  // 当前烹饪进度，0~1
  currentStation?: Station;          // 当前所在的工作站
}

// 举例：切好的番茄
const slicedTomato: Food = {
  components: [tomatoIngredient],
  cookStates: ['cut'],
  isCooking: false,
  progress: 0
};

// 举例：生菜番茄沙拉
const salad: Food = {
  components: [slicedLettuce, slicedTomato], // 两个已切好的食物
  cookStates: [],                             // 沙拉不需要额外烹饪
  isCooking: false,
  progress: 0
};

// 举例：清蛋糕（搅拌后烤制）
const plainCake: Food = {
  components: [
    {
      components: [eggIngredient, flourIngredient],
      cookStates: ['mix'],  // 先搅拌
      isCooking: false,
      progress: 0
    }
  ],
  cookStates: ['mix', 'pan-fry'], // 搅拌后煎烤
  isCooking: false,
  progress: 0
};
```

#### 烹饪类型

##### 分类

可以有一下几种烹饪类型，基本每种烹饪类型都对应一个工作站：

- 单食材烹饪方式，只对单个食材进行处理
  - 切: (在文件:"./菜单.md"中使用`/`表示) 对应菜板 CutStation
  - 煮: (在文件:"./菜单.md"中使用`*`表示) 对应煮锅
  - 炸: 没有在菜单中出现, 对应炸锅
- 多食物烹饪，可以对多个食材或者进行了加工的多个食物进行处理
  - 炒: (在文件:"./菜单.md"中使用`《》`表示) 对应炒锅 PotStation
  - 烤: 没有在菜单中出现，对应烧烤架
  - 搅拌: (在文件:"./菜单.md"中使用`｛｝`表示) 对应搅拌器
  - 烘焙:没有在菜单中出现, 对应烤箱

##### 举例

以胡闹厨房菜单中的菜品展示不同烹饪类型的应用：

1. **单食材烹饪**
   - 切（/）：生菜沙拉中的「生菜/」，鱼刺身「鱼/」
   - 煮（*）：寿司中的「米*」，热狗中的「香肠*」
   - 炸（/*）：炸鸡块「鸡腿/*」，炸土豆「土豆/_」

2. **多食物烹饪**
   - 炒《》：洋葱土豆汤「《洋葱/+土豆/+胡萝卜/》」
   - 搅拌｛｝：清蛋糕「｛鸡蛋+面粉｝」，鲜肉小笼「｛面粉+肉/｝」
   - 烘焙：蜂蜜蛋糕「《｛鸡蛋+面粉+蜂窝/｝》烤箱」

3. **复合烹饪（多步骤）**
   - 鲜肉小笼：先搅拌「｛面粉+肉/｝」，再蒸
   - 巧克力蛋糕：先搅拌「｛鸡蛋+面粉+巧克力/｝」，再煎
   - 披萨：先组合「面皮/+芝士/+番茄/」，再烘焙

##### 伪代码

```ts
// 单食材烹饪状态
type SingleCookState = 'cut' | 'boil' | 'deep-fry';

// 多食物烹饪状态
type MultiCookState = 'stir-fry' | 'barbecue' | 'mix' | 'bake';

// 所有烹饪状态
type CookState = SingleCookState | MultiCookState;

// 特殊状态
type SpecialState = 'overcook' | 'burnt'; // 过度烹饪、烧焦

// 烹饪类型配置
interface CookTypeConfig {
  type: CookState;
  displayName: string;       // 显示名称
  symbol: string;            // 菜单符号表示
  isSingle: boolean;         // 是否为单食材烹饪
  station: string;           // 对应工作站类型
  baseTime: number;          // 基础烹饪时间（毫秒）
  canOvercook: boolean;      // 是否会过度烹饪
}

// 烹饪类型注册表
const COOK_TYPES: Record<CookState, CookTypeConfig> = {
  'cut': {
    type: 'cut',
    displayName: '切',
    symbol: '/',
    isSingle: true,
    station: 'CutStation',
    baseTime: 3000,
    canOvercook: false
  },
  'boil': {
    type: 'boil',
    displayName: '煮',
    symbol: '*',
    isSingle: true,
    station: 'BoilStation',
    baseTime: 5000,
    canOvercook: true
  },
  'deep-fry': {
    type: 'deep-fry',
    displayName: '炸',
    symbol: '/_',
    isSingle: true,
    station: 'FryStation',
    baseTime: 4000,
    canOvercook: true
  },
  'stir-fry': {
    type: 'stir-fry',
    displayName: '炒/煮汤',
    symbol: '《》',
    isSingle: false,
    station: 'PotStation',
    baseTime: 6000,
    canOvercook: true
  },
  'mix': {
    type: 'mix',
    displayName: '搅拌',
    symbol: '｛｝',
    isSingle: false,
    station: 'MixerStation',
    baseTime: 4000,
    canOvercook: false
  },
  'bake': {
    type: 'bake',
    displayName: '烘焙',
    symbol: '',
    isSingle: false,
    station: 'OvenStation',
    baseTime: 8000,
    canOvercook: true
  },
  'barbecue': {
    type: 'barbecue',
    displayName: '烧烤',
    symbol: '',
    isSingle: false,
    station: 'GrillStation',
    baseTime: 5000,
    canOvercook: true
  }
};
```

#### 烹饪工作站

为食物进行加工的工作站，每个烹饪工作站对应一个或者多个烹饪方式。

根据烹饪工作站的烹饪方式，烹饪工作站也可以分为单食材工作站、多食物工作站：

- 单食材工作站：工作站输入一个食材，工作完毕后会输出一个加工后的食物
- 多食物工作站：工作站输入多个食材或食物，工作完毕后会输出一个加工后的食物

##### 举例

1. **单食材工作站**
   - 菜板（CutStation）：放入生菜 → 输出切好的生菜
   - 煮锅（BoilStation）：放入米 → 输出煮好的米
   - 炸锅（FryStation）：放入切好的鸡腿 → 输出炸好的鸡块

2. **多食物工作站**
   - 炒锅/汤锅（PotStation）：
     - 放入切好的洋葱+土豆+胡萝卜 → 输出洋葱土豆胡萝卜汤
   - 搅拌器（MixerStation）：
     - 放入鸡蛋+面粉 → 输出搅拌好的面糊（用于制作蛋糕）
     - 放入面粉+切好的肉 → 输出小笼包面团
   - 烤箱（OvenStation）：
     - 放入搅拌好的蛋糕面糊 → 输出烤好的蛋糕
     - 放入组合好的披萨胚 → 输出烤好的披萨

3. **特殊容器型工作站**
   - 有些工作站需要特定容器才能工作，如：
     - 汤锅需要锅容器
     - 搅拌器需要搅拌容器

##### 伪代码

```ts
// 工作站状态
type StationWorkStatus = 'idle' | 'working' | 'done' | 'danger' | 'fire';

// 工作站基类接口
interface CookStation {
  id: string;
  type: string;                    // 工作站类型标识
  displayName: string;             // 显示名称
  workStatus: StationWorkStatus;   // 当前状态
  cookTypes: CookState[];          // 支持的烹饪方式
  isSingleInput: boolean;          // 是否为单食材输入
  
  item: Item | null;               // 当前持有的物品
  workSpeed: number;               // 工作速度倍率
  
  // 时间配置（针对可过度烹饪的工作站）
  safeTime?: number;               // 完成后的安全时间
  dangerTime?: number;             // 危险状态持续时间
  
  // 状态标志
  canPick: boolean;                // 是否可拾取物品
  canFire: boolean;                // 是否会着火
  useStationBar: boolean;          // 使用工作站进度条还是物品进度条
}

// 单食材工作站
interface SingleInputStation extends CookStation {
  isSingleInput: true;
  canAccept(ingredient: Ingredient): boolean;  // 判断是否接受该食材
  process(ingredient: Ingredient): Food;        // 加工食材
}

// 多食物工作站
interface MultiInputStation extends CookStation {
  isSingleInput: false;
  maxInputs: number;                            // 最大输入数量
  canAccept(food: Food | Ingredient): boolean;  // 判断是否接受该食物/食材
  canStartCooking(): boolean;                   // 判断是否可以开始烹饪
  process(foods: (Food | Ingredient)[]): Food;  // 加工多个食物
}

// 具体工作站示例

// 菜板 - 单食材工作站
const cutStation: SingleInputStation = {
  id: 'cut-station-1',
  type: 'CutStation',
  displayName: '菜板',
  workStatus: 'idle',
  cookTypes: ['cut'],
  isSingleInput: true,
  item: null,
  workSpeed: 1.0,
  canPick: true,
  canFire: false,
  useStationBar: false,
  canAccept: (ingredient) => ingredient.cookStates.length === 0, // 只接受未加工的食材
  process: (ingredient) => ({
    components: [ingredient],
    cookStates: ['cut'],
    isCooking: false,
    progress: 0
  })
};

// 搅拌器 - 多食物工作站
const mixerStation: MultiInputStation = {
  id: 'mixer-station-1',
  type: 'MixerStation',
  displayName: '搅拌器',
  workStatus: 'idle',
  cookTypes: ['mix'],
  isSingleInput: false,
  maxInputs: 4,
  item: null,
  workSpeed: 1.0,
  canPick: true,
  canFire: false,
  useStationBar: true,
  canAccept: (food) => true, // 搅拌器接受大部分食物
  canStartCooking: () => true,
  process: (foods) => ({
    components: foods,
    cookStates: ['mix'],
    isCooking: false,
    progress: 0
  })
};

// 汤锅 - 多食物工作站，可过度烹饪
const potStation: MultiInputStation = {
  id: 'pot-station-1',
  type: 'PotStation',
  displayName: '汤锅',
  workStatus: 'idle',
  cookTypes: ['stir-fry', 'boil'],
  isSingleInput: false,
  maxInputs: 3,
  item: null,
  workSpeed: 1.0,
  safeTime: 5000,      // 完成后5秒安全时间
  dangerTime: 3000,    // 危险状态3秒后着火
  canPick: true,
  canFire: true,
  useStationBar: false,
  canAccept: (food) => {
    // 只接受切好或煮好的食材
    if ('cookStates' in food) {
      return food.cookStates.includes('cut') || food.cookStates.includes('boil');
    }
    return false;
  },
  canStartCooking: () => true,
  process: (foods) => ({
    components: foods,
    cookStates: ['stir-fry'],
    isCooking: false,
    progress: 0
  })
};
```

#### 容器

容器本身是承载食物的载体，只用装 Food，而 Food 中具体食物组合则不关心。

##### 举例

1. **盘子（Plate）** - 通用容器
   - 用途：盛放已完成的菜品，用于出餐
   - 特点：可装多种食材组合，有脏/干净状态
   - 示例：
     - 盛放生菜番茄沙拉
     - 盛放烤好的蛋糕
     - 盛放煮好的汤

2. **锅（Pot）** - 烹饪容器
   - 用途：在灶台上煮汤或炒菜
   - 特点：只能装同类型或兼容的食材
   - 示例：
     - 装入切好的洋葱、土豆、胡萝卜制作汤
     - 装入切好的番茄和面制作意面

3. **搅拌碗（Bowl）** - 搅拌器专用容器
   - 用途：在搅拌器中混合食材
   - 示例：装入鸡蛋+面粉制作蛋糕面糊

4. **杯子（Cup）** - 饮料容器
   - 用途：盛放饮料
   - 示例：巧克力牛奶、果汁

##### 基底食材

汉堡面包、卷饼、热狗面包、披萨面皮等**本质上是食材**，而不是容器。它们的特殊之处在于：

- 可以作为"基底"直接与其他配料组合成 Food
- 组合时不需要先放到盘子里
- 组合后形成的 Food 可以直接放在工作站上或者地上, 但是不可以直接上菜

这些基底食材通过 `Ingredient` 的 `canBeBase` 属性标识，组合逻辑在 Food 层面处理。

##### 伪代码

```ts
// 容器状态
type ContainerStatus = 'empty' | 'dirty' | 'combinable' | 'full';

// 容器类型
type ContainerType = 'plate' | 'pot' | 'bowl' | 'cup';

// 容器基类接口
interface Container {
  id: string;
  type: ContainerType;
  displayName: string;
  status: ContainerStatus;
  food: Food | null;           // 容器内的食物
  maxCapacity: number;         // 最大容量（食材数量）
  canTransfer: boolean;        // 是否可转移内容到其他容器
  
  // 方法
  isEmpty(): boolean;
  isFull(): boolean;
  canAddFood(food: Food | Ingredient): boolean;
  addFood(food: Food | Ingredient): boolean;
  transferTo(target: Container): boolean;
  clear(): void;
}

// 盘子 - 通用出餐容器
interface Plate extends Container {
  type: 'plate';
  canTransfer: true;
  makeDirty(): void;
  wash(): void;
}

// 锅 - 烹饪容器
interface Pot extends Container {
  type: 'pot';
  canTransfer: true;
}
```

##### 基底食材的定义

```ts
// 食材接口扩展
interface Ingredient {
  name: string;
  displayName: string;
  homeStation: Station;
  texture: string;
  cookStates: CookState[];
  
  // 基底食材相关
  canBeBase: boolean;              // 是否可作为基底直接组合配料
  acceptedToppings?: string[];     // 可接受的配料类型（仅基底食材有效）
  maxToppings?: number;            // 最大配料数量
}

// 基底食材示例

// 汉堡面包 - 基底食材
const burgerBun: Ingredient = {
  name: 'burger-bun',
  displayName: '汉堡面包',
  homeStation: burgerBunStation,
  texture: 'burger-bun.png',
  cookStates: [],
  canBeBase: true,
  acceptedToppings: ['meat', 'cheese', 'lettuce', 'tomato', 'pineapple'],
  maxToppings: 4
};

// 卷饼 - 基底食材
const tortilla: Ingredient = {
  name: 'tortilla',
  displayName: '卷饼',
  homeStation: tortillaStation,
  texture: 'tortilla.png',
  cookStates: [],
  canBeBase: true,
  acceptedToppings: ['meat', 'chicken', 'mushroom', 'rice'],
  maxToppings: 3
};

// 披萨面皮 - 基底食材（需要切）
const pizzaDough: Ingredient = {
  name: 'pizza-dough',
  displayName: '披萨面皮',
  homeStation: pizzaDoughStation,
  texture: 'pizza-dough.png',
  cookStates: [],
  canBeBase: true,
  acceptedToppings: ['cheese', 'tomato', 'sausage', 'chicken', 'berry'],
  maxToppings: 4
};

// 普通食材（番茄）- 非基底
const tomato: Ingredient = {
  name: 'tomato',
  displayName: '番茄',
  homeStation: tomatoStation,
  texture: 'tomato.png',
  cookStates: [],
  canBeBase: false  // 普通食材不能作为基底
};
```

##### 基底食材的组合逻辑

```ts
// Food 组合方法
class Food {
  components: (Food | Ingredient)[];
  cookStates: CookState[];
  
  // 判断是否可以添加配料
  canAddTopping(topping: Food | Ingredient): boolean {
    // 找到基底食材
    const base = this.getBaseIngredient();
    if (!base || !base.canBeBase) return false;
    
    // 检查配料数量限制
    const currentToppings = this.components.length - 1; // 减去基底
    if (base.maxToppings && currentToppings >= base.maxToppings) return false;
    
    // 检查配料类型是否被接受
    const toppingType = this.getToppingType(topping);
    if (base.acceptedToppings && !base.acceptedToppings.includes(toppingType)) {
      return false;
    }
    
    return true;
  }
  
  // 获取基底食材
  getBaseIngredient(): Ingredient | null {
    for (const comp of this.components) {
      if ('canBeBase' in comp && comp.canBeBase) {
        return comp as Ingredient;
      }
    }
    return null;
  }
}

// 汉堡组合示例
// 玩家手持煎好的肉饼，靠近汉堡面包，触发组合
const burger: Food = {
  components: [
    burgerBun,           // 基底食材
    friedMeatPatty,      // 煎好的肉饼（Food）
    slicedCheese         // 切好的芝士（Food）
  ],
  cookStates: [],        // 汉堡本身不需要额外烹饪
  isCooking: false,
  progress: 0
};
```

#### 订单

订单是游戏的核心驱动，代表顾客的需求。玩家需要根据订单要求制作相应的菜品并在规定时间内交付。

##### 核心设计思路

**菜谱直接用 Food 结构定义目标菜品**，验证时将玩家提交的 Food 与订单的目标 Food 进行结构比较，相等则认为符合上菜要求。

这种设计的优点：

- 数据结构统一，菜谱定义和实际食物使用相同的 Food 结构
- 匹配逻辑简单直观，只需比较两个 Food 是否等价
- 易于扩展，新增菜品只需定义对应的 Food 结构

##### 订单组成

- **目标食物（targetFood）**：使用 Food 结构描述的目标菜品
- **时间限制**：订单的有效期
- **奖励/惩罚**：完成订单的得分或超时的扣分

##### 举例

1. **简单订单 - 生菜沙拉**
   - 目标食物：`{ components: [切好的生菜], cookStates: [] }`
   - 时间限制：60秒

2. **中等订单 - 鱼寿司**
   - 目标食物：`{ components: [切好的鱼, 煮好的米, 紫菜], cookStates: [] }`
   - 时间限制：90秒

3. **复杂订单 - 清蛋糕**
   - 目标食物：`{ components: [搅拌后的面糊], cookStates: ['pan-fry'] }`
   - 其中搅拌后的面糊：`{ components: [鸡蛋, 面粉], cookStates: ['mix'] }`
   - 时间限制：120秒

##### 伪代码

```ts
// ============ 菜谱定义 ============

// 菜谱使用 Food 结构直接定义目标菜品
interface Recipe {
  id: string;              // 菜谱唯一ID
  category: string;        // 分类，如 'salad', 'sushi', 'cake'
  name: string;            // 菜品名称
  displayName: string;     // 显示名称
  targetFood: Food;        // 目标食物结构
  difficulty: number;      // 难度等级 1-5
}

// ============ 订单定义 ============

interface Order {
  id: string;              // 订单唯一ID
  recipe: Recipe;          // 对应的菜谱
  createdAt: number;       // 创建时间戳
  timeLimit: number;       // 时间限制（毫秒）
  tipMultiplier: number;   // 小费倍率（根据剩余时间计算）
  status: OrderStatus;     // 订单状态
}

type OrderStatus = 'pending' | 'completed' | 'expired' | 'failed';

// ============ Food 比较逻辑 ============

class FoodMatcher {
  /**
   * 比较两个 Food 是否等价
   * 用于验证玩家提交的食物是否符合订单要求
   */
  static equals(submitted: Food, target: Food): boolean {
    // 1. 比较烹饪状态链
    if (!this.cookStatesEqual(submitted.cookStates, target.cookStates)) {
      return false;
    }
    
    // 2. 比较组件数量
    if (submitted.components.length !== target.components.length) {
      return false;
    }
    
    // 3. 比较组件内容（无序匹配）
    return this.componentsMatch(submitted.components, target.components);
  }
  
  /**
   * 比较烹饪状态链是否相等
   */
  static cookStatesEqual(a: CookState[], b: CookState[]): boolean {
    if (a.length !== b.length) return false;
    // 烹饪状态是有序的，必须完全一致
    return a.every((state, i) => state === b[i]);
  }
  
  /**
   * 比较组件是否匹配（无序）
   * 使用贪婪匹配算法，确保每个目标组件都能找到对应的提交组件
   */
  static componentsMatch(
    submitted: (Food | Ingredient)[],
    target: (Food | Ingredient)[]
  ): boolean {
    const used = new Set<number>();
    
    for (const targetComp of target) {
      let found = false;
      
      for (let i = 0; i < submitted.length; i++) {
        if (used.has(i)) continue;
        
        if (this.componentEquals(submitted[i], targetComp)) {
          used.add(i);
          found = true;
          break;
        }
      }
      
      if (!found) return false;
    }
    
    return true;
  }
  
  /**
   * 比较单个组件是否相等
   */
  static componentEquals(
    a: Food | Ingredient,
    b: Food | Ingredient
  ): boolean {
    // 如果都是 Ingredient
    if (this.isIngredient(a) && this.isIngredient(b)) {
      return this.ingredientEquals(a, b);
    }
    
    // 如果都是 Food
    if (this.isFood(a) && this.isFood(b)) {
      return this.equals(a, b); // 递归比较
    }
    
    // 类型不同
    return false;
  }
  
  /**
   * 比较两个 Ingredient 是否相等
   */
  static ingredientEquals(a: Ingredient, b: Ingredient): boolean {
    // 食材类型必须相同
    if (a.name !== b.name) return false;
    // 烹饪状态链必须相同
    return this.cookStatesEqual(a.cookStates, b.cookStates);
  }
  
  static isIngredient(item: Food | Ingredient): item is Ingredient {
    return 'name' in item && !('components' in item);
  }
  
  static isFood(item: Food | Ingredient): item is Food {
    return 'components' in item;
  }
}

// ============ 订单管理器 ============

interface OrderManager {
  orders: Order[];              // 当前订单池
  recipePool: Recipe[];         // 可用菜谱池
  maxOrders: number;            // 最大同时订单数
  
  // 生成新订单
  generateOrder(recipe?: Recipe): Order | null;
  
  // 验证交付：比较提交的 Food 与订单的 targetFood
  validateDelivery(submittedFood: Food): Order | null;
  
  // 清理过期订单
  clearExpiredOrders(): Order[];
  
  // 完成订单
  completeOrder(orderId: string, remainingTime: number): number; // 返回得分
}

// ============ 具体菜谱示例 ============

// 辅助函数：创建加工后的食材
function processedIngredient(name: string, cookStates: CookState[]): Ingredient {
  return {
    name,
    displayName: '',
    homeStation: null,
    texture: '',
    cookStates,
    canBeBase: false
  };
}

// 生菜沙拉
const lettuceSaladRecipe: Recipe = {
  id: 'lettuce-salad',
  category: 'salad',
  name: 'lettuce-salad',
  displayName: '生菜沙拉',
  difficulty: 1,
  targetFood: {
    components: [
      processedIngredient('lettuce', ['cut'])  // 切好的生菜
    ],
    cookStates: [],
    isCooking: false,
    progress: 0
  }
};

// 生菜番茄沙拉
const lettuceTomatoSaladRecipe: Recipe = {
  id: 'lettuce-tomato-salad',
  category: 'salad',
  name: 'lettuce-tomato-salad',
  displayName: '生菜番茄沙拉',
  difficulty: 1,
  targetFood: {
    components: [
      processedIngredient('lettuce', ['cut']),  // 切好的生菜
      processedIngredient('tomato', ['cut'])    // 切好的番茄
    ],
    cookStates: [],
    isCooking: false,
    progress: 0
  }
};

// 鱼寿司
const fishSushiRecipe: Recipe = {
  id: 'fish-sushi',
  category: 'japanese',
  name: 'fish-sushi',
  displayName: '鱼寿司',
  difficulty: 2,
  targetFood: {
    components: [
      processedIngredient('fish', ['cut']),     // 切好的鱼
      processedIngredient('rice', ['boil']),    // 煮好的米
      processedIngredient('seaweed', [])        // 紫菜（不需要加工）
    ],
    cookStates: [],
    isCooking: false,
    progress: 0
  }
};

// 清蛋糕（嵌套结构：搅拌后煎烤）
const plainCakeRecipe: Recipe = {
  id: 'plain-cake',
  category: 'cake',
  name: 'plain-cake',
  displayName: '清蛋糕',
  difficulty: 3,
  targetFood: {
    components: [
      // 嵌套的 Food：搅拌后的面糊
      {
        components: [
          processedIngredient('egg', []),       // 鸡蛋
          processedIngredient('flour', [])      // 面粉
        ],
        cookStates: ['mix'],                    // 经过搅拌
        isCooking: false,
        progress: 0
      }
    ],
    cookStates: ['pan-fry'],                    // 整体经过煎烤
    isCooking: false,
    progress: 0
  }
};

// 洋葱土豆胡萝卜汤
const vegetableSoupRecipe: Recipe = {
  id: 'vegetable-soup',
  category: 'soup',
  name: 'vegetable-soup',
  displayName: '洋葱土豆胡萝卜汤',
  difficulty: 2,
  targetFood: {
    components: [
      processedIngredient('onion', ['cut']),    // 切好的洋葱
      processedIngredient('potato', ['cut']),   // 切好的土豆
      processedIngredient('carrot', ['cut'])    // 切好的胡萝卜
    ],
    cookStates: ['stir-fry'],                   // 一起煮
    isCooking: false,
    progress: 0
  }
};

// 肉堡（基底食材示例）
const meatBurgerRecipe: Recipe = {
  id: 'meat-burger',
  category: 'burger',
  name: 'meat-burger',
  displayName: '肉堡',
  difficulty: 2,
  targetFood: {
    components: [
      processedIngredient('burger-bun', []),    // 汉堡面包（基底）
      processedIngredient('meat', ['cut', 'pan-fry'])  // 切好并煎好的肉
    ],
    cookStates: [],
    isCooking: false,
    progress: 0
  }
};

// ============ 订单实例示例 ============

const sampleOrder: Order = {
  id: 'order-001',
  recipe: lettuceTomatoSaladRecipe,
  createdAt: Date.now(),
  timeLimit: 60000,  // 60秒
  tipMultiplier: 1.0,
  status: 'pending'
};

// ============ 验证流程示例 ============

// 玩家制作的食物
const playerFood: Food = {
  components: [
    { name: 'tomato', cookStates: ['cut'], /* ... */ },
    { name: 'lettuce', cookStates: ['cut'], /* ... */ }
  ],
  cookStates: [],
  isCooking: false,
  progress: 0
};

// 验证是否符合订单
const isMatch = FoodMatcher.equals(playerFood, sampleOrder.recipe.targetFood);
// isMatch === true，因为组件内容相同（顺序无关）
```

---

## 解决方案

基于对现有代码架构的分析，以下是具体的修改方案和实施步骤。

### 现有代码架构概述

当前项目的食物系统主要由以下模块组成：

| 模块 | 文件路径 | 职责 |
|------|----------|------|
| Item | `src/game/item/index.ts` | 所有可拾取物品的抽象基类 |
| Ingredient | `src/game/item/ingredient/ingredient.ts` | 食材类，管理 `cookStates` 状态链 |
| Food | `src/game/item/food.ts` | 食材集合管理，继承自 Phaser.Sprite |
| Container | `src/game/item/container/container.ts` | 容器抽象基类 |
| Pot/Plate | `src/game/item/container/pot.ts`, `plate.ts` | 具体容器实现 |
| Station | `src/game/stations/station.ts` | 工作站抽象基类，实现状态机 |
| CutStation | `src/game/stations/cut-station.ts` | 切菜站 |
| PotStation | `src/game/stations/pot-station.ts` | 灶台/煮锅站 |
| OrderManager | `src/game/recipe/order-manager.ts` | 订单管理 |
| RecipeMatcher | `src/game/recipe/recipe-matcher.ts` | 菜谱匹配逻辑 |
| types | `src/game/recipe/types.ts` | 类型定义 |

### 第一阶段：扩展烹饪状态类型

**目标**：支持搅拌（mix）、烘焙（bake）、烧烤（barbecue）等新烹饪方式。

#### 步骤 1.1：修改 CookState 类型定义

修改 `src/game/item/ingredient/ingredient.ts` 中的 `CookState` 类型：

- 添加新的烹饪状态：`'mix'`、`'bake'`、`'barbecue'`、`'steam'`（蒸）
- 将 `CookState` 拆分为 `SingleCookState` 和 `MultiCookState` 两个子类型
- 添加 `SpecialState` 类型用于表示 `'overcook'`、`'burnt'` 等异常状态

#### 步骤 1.2：创建烹饪类型配置注册表

在 `src/game/recipe/` 目录下新建 `cook-types.ts` 文件：

- 定义 `CookTypeConfig` 接口，包含类型、显示名称、符号、对应工作站等配置
- 创建 `COOK_TYPES` 常量对象，注册所有烹饪类型的配置信息
- 导出辅助函数 `getCookTypeConfig(type: CookState)` 用于获取配置

### 第二阶段：重构 Food 类支持嵌套组合

**目标**：使 Food 能够包含其他 Food，支持复杂菜品的多步骤制作流程。

#### 步骤 2.1：修改 Food 类的数据结构

修改 `src/game/item/food.ts`：

- 将 `ingredients: Ingredient[]` 改为 `components: (Food | Ingredient)[]`
- 添加 `cookStates: CookState[]` 属性到 Food 类本身（目前只在 Ingredient 上有）
- 添加 `isCooking: boolean` 和 `currentStation?: Station` 属性

#### 步骤 2.2：修改 Food 类的方法

- 修改 `add()` 方法，支持添加 Food 或 Ingredient
- 修改 `getProgress()` 和 `setProgress()` 方法，递归处理嵌套的 Food
- 添加 `addCookState(state: CookState)` 方法
- 添加 `flatten(): Ingredient[]` 方法，用于展平嵌套结构获取所有原始食材

#### 步骤 2.3：更新 Container 类

修改 `src/game/item/container/container.ts`：

- 更新 `canAddIngredient()` 方法签名为 `canAdd(item: Food | Ingredient)`
- 修改 `transferTo()` 方法支持 Food 的嵌套转移

### 第三阶段：新增工作站类型

**目标**：实现搅拌器、烤箱等新工作站。

#### 步骤 3.1：创建 MixerStation（搅拌器）

在 `src/game/stations/` 目录下新建 `mixer-station.ts`：

- 继承 `Station` 基类
- 设置 `cookTypes: ['mix']`
- 实现多食材输入逻辑：允许放入多个食材/食物
- 工作完成后输出一个带有 `'mix'` 状态的 Food
- 搅拌器不会过度烹饪（`canFire: false`）

#### 步骤 3.2：创建 OvenStation（烤箱）

在 `src/game/stations/` 目录下新建 `oven-station.ts`：

- 继承 `Station` 基类
- 设置 `cookTypes: ['bake']`
- 实现类似 PotStation 的状态机：idle -> working -> done -> danger -> fire
- 只接受已搅拌或已组合的食物（如披萨胚、蛋糕面糊）
- 配置 `safeTime`、`dangerTime` 参数

#### 步骤 3.3：创建 BoilStation（煮锅）

在 `src/game/stations/` 目录下新建 `boil-station.ts`：

- 继承 `Station` 基类
- 设置 `cookTypes: ['boil']`
- 单食材输入：一次只能煮一个食材（如米）
- 实现过度烹饪逻辑

#### 步骤 3.4：创建 FryStation（炸锅）

在 `src/game/stations/` 目录下新建 `fry-station.ts`：

- 继承 `Station` 基类
- 设置 `cookTypes: ['deep-fry']`
- 只接受已切好的食材
- 实现过度烹饪逻辑

#### 步骤 3.5：创建 GrillStation（烧烤架）

在 `src/game/stations/` 目录下新建 `grill-station.ts`：

- 继承 `Station` 基类
- 设置 `cookTypes: ['barbecue']`
- 多食材输入
- 实现过度烹饪逻辑

#### 步骤 3.6：更新 StationManager

修改 `src/game/manager/station-manager.ts`：

- 在 `createStation()` 方法中添加新工作站类型的创建逻辑
- 更新工作站类型枚举或类型定义

### 第四阶段：实现基底食材

**目标**：支持汉堡面包、卷饼等可直接组合配料的基底食材。

#### 步骤 4.1：扩展 Ingredient 接口

修改 `src/game/item/ingredient/ingredient.ts`：

- 添加 `canBeBase: boolean` 属性，标识该食材是否可作为基底
- 添加 `acceptedToppings?: string[]` 属性，定义可接受的配料类型
- 添加 `maxToppings?: number` 属性，限制最大配料数量

#### 步骤 4.2：创建具体基底食材类

在 `src/game/item/ingredient/` 目录下创建：

- `BurgerBun`：汉堡面包，`canBeBase: true`，接受肉、芝士、生菜、番茄等
- `Tortilla`：卷饼，`canBeBase: true`，接受肉、米、蘑菇等
- `HotdogBun`：热狗面包，`canBeBase: true`，接受香肠、洋葱等
- `PizzaDough`：披萨面皮，`canBeBase: true`，接受芝士、番茄、各种配料

#### 步骤 4.3：修改 Food 类的组合逻辑

修改 `src/game/item/food.ts`：

- 添加 `getBaseIngredient(): Ingredient | null` 方法，获取基底食材
- 添加 `canAddTopping(topping: Food | Ingredient): boolean` 方法，验证配料是否可添加
- 修改 `add()` 方法，支持基底食材的配料组合逻辑

#### 步骤 4.4：修改交互逻辑

修改 `src/game/player/interact-helper.ts`：

- 当玩家手持配料靠近基底食材（或包含基底食材的 Food）时，触发组合
- 组合时调用 `Food.canAddTopping()` 验证是否允许

### 第五阶段：简化菜谱匹配系统

**目标**：菜谱直接用 Food 结构定义目标菜品，验证时比较两个 Food 是否等价。

#### 步骤 5.1：更新类型定义

修改 `src/game/recipe/types.ts`：

- 移除 `RecipeRequirement` 类型
- 新增 `Recipe` 类型，包含 `targetFood: Food` 字段
- 更新 `Order` 类型，使用新的 `Recipe`

#### 步骤 5.2：创建 FoodMatcher 工具类

修改 `src/game/recipe/recipe-matcher.ts`，重构为 `FoodMatcher`：

- 实现 `equals(submitted: Food, target: Food): boolean` 方法
- 实现 `cookStatesEqual(a: CookState[], b: CookState[]): boolean` 方法
- 实现 `componentsMatch(submitted, target): boolean` 方法，使用无序匹配算法
- 实现 `componentEquals(a, b): boolean` 方法，递归比较 Food 或 Ingredient
- 实现 `ingredientEquals(a: Ingredient, b: Ingredient): boolean` 方法

#### 步骤 5.3：更新 OrderManager

修改 `src/game/recipe/order-manager.ts`：

- 更新 `recipePool` 类型为 `Recipe[]`
- 修改 `validateDelivery(submittedFood: Food)` 方法，遍历订单调用 `FoodMatcher.equals()`
- 简化得分计算逻辑

### 第六阶段：新增食材类型

**目标**：添加蛋糕、小笼包、披萨等菜品所需的食材。

#### 步骤 6.1：创建新食材类

在 `src/game/item/ingredient/` 目录下创建新食材类：

- `Egg`：鸡蛋
- `Flour`：面粉
- `Rice`：米
- `Seaweed`：紫菜
- `Meat`：肉
- `Onion`：洋葱
- `Potato`：土豆
- `Carrot`：胡萝卜
- `Cheese`：芝士
- `Chocolate`：巧克力
- `Honey`：蜂蜜

每个食材类继承 `Ingredient` 基类，设置对应的 `ingredientType` 和纹理资源。

#### 步骤 6.2：创建对应的 IngredientStation

为每种新食材创建对应的食材箱工作站，使用泛型类 `IngredientStation<T>`。

#### 步骤 6.3：更新资源加载

修改 `src/game/scenes/` 中的场景文件，添加新食材的纹理资源预加载。

### 第七阶段：定义菜谱数据

**目标**：创建完整的菜谱数据文件。

#### 步骤 7.1：创建菜谱数据文件

在 `src/game/recipe/` 目录下新建 `recipes/` 子目录，按分类创建菜谱数据：

- `salad-recipes.ts`：沙拉类菜谱
- `japanese-recipes.ts`：日料类菜谱（刺身、寿司）
- `pasta-recipes.ts`：意面类菜谱
- `cake-recipes.ts`：蛋糕类菜谱
- `soup-recipes.ts`：汤类菜谱
- `burger-recipes.ts`：汉堡类菜谱

#### 步骤 7.2：创建菜谱注册表

在 `src/game/recipe/` 目录下新建 `recipe-registry.ts`：

- 汇总所有菜谱数据
- 提供按分类、按难度查询菜谱的方法
- 导出 `getAllRecipes()`、`getRecipesByCategory()`、`getRecipeById()` 等方法

### 实施顺序建议

按依赖关系，建议按以下顺序实施：

1. **第一阶段**（基础）：扩展 CookState 类型 - 其他所有修改的前置依赖
2. **第二阶段**（核心）：重构 Food 类 - 支持嵌套组合是核心功能
3. **第六阶段**（数据）：新增食材类型 - 为测试新工作站做准备
4. **第三阶段**（功能）：新增工作站类型 - 可以逐个工作站增量实现
5. **第四阶段**（功能）：实现基底食材 - 可与第三阶段并行
6. **第五阶段**（系统）：简化菜谱匹配 - 需要前面的修改完成
7. **第七阶段**（数据）：定义菜谱数据 - 最后配置具体菜谱

### 测试要点

每个阶段完成后应验证：

1. **第一阶段**：确认新 CookState 类型可以正确赋值和比较
2. **第二阶段**：测试 Food 嵌套创建、展平、进度计算
3. **第三阶段**：测试各工作站的状态机流转、过度烹饪逻辑
4. **第四阶段**：测试基底食材的配料组合逻辑（汉堡面包+肉饼等）
5. **第五阶段**：测试 FoodMatcher.equals() 对各种 Food 结构的比较正确性
6. **第六阶段**：确认新食材可以正常生成和使用
7. **第七阶段**：测试各菜谱的完整制作流程和出餐验证
