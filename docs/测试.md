# 测试框架设计文档

## 1. 概述

### 1.1 项目背景

Overcook-web 是一个基于 Phaser 3 的 TypeScript 烹饪游戏，使用 Vite 构建，Vitest 测试。

**技术栈：**

- 运行时：TypeScript + Phaser 3
- 构建工具：Vite
- 测试框架：Vitest
- 包管理器：pnpm

### 1.2 测试目标

- **单元测试**：核心游戏逻辑（菜谱匹配、订单管理、物品状态）
- **集成测试**：工作站与物品交互、玩家操作
- **UI 测试**：菜单导航、游戏开始/重启流程
- **可视化测试**：精灵图渲染验证

### 1.3 测试命令

```bash
# 运行全部测试（单次）
pnpm test

# 监听模式运行测试
pnpm test:watch

# 带 UI 界面运行测试
pnpm test:ui

# 运行指定测试文件
pnpm test src/game/recipe/food-matcher.test.ts

# 运行匹配指定模式的测试
pnpm test --grep "OrderManager"
```

---

## 2. 架构设计

### 2.1 目录结构

```
src/
├── game/
│   ├── helper/
│   │   ├── fire-helper.ts
│   │   ├── fire-helper.test.ts        # 已有
│   │   └── interact-helper.test.ts    # 待添加
│   ├── item/
│   │   ├── fire-extinguisher.ts
│   │   ├── fire-extinguisher.test.ts  # 已有
│   │   ├── food.test.ts               # 待添加
│   │   ├── ingredient/
│   │   │   └── ingredient.test.ts     # 待添加
│   │   └── container/
│   │       └── container.test.ts      # 待添加
│   ├── recipe/
│   │   ├── food-matcher.test.ts       # 待添加（高优先级）
│   │   └── order-manager.test.ts      # 待添加（高优先级）
│   ├── stations/
│   │   ├── station.test.ts            # 待添加
│   │   ├── pot-station.test.ts        # 待添加
│   │   └── cut-station.test.ts        # 待添加
│   ├── player/
│   │   └── player.test.ts             # 待添加
│   └── scenes/
│       └── game-scene.test.ts         # 待添加（菜单 UI 测试）
└── __mocks__/                         # 共享 mock
    └── phaser.ts
```

### 2.2 测试分类

| 分类 | 范围 | 优先级 |
|------|------|--------|
| 菜谱系统 | FoodMatcher, OrderManager | P0 |
| 物品系统 | Food, Ingredient, Container | P0 |
| 工作站系统 | Station 基类, PotStation, CutStation | P1 |
| 玩家系统 | 玩家操作、交互 | P1 |
| 辅助系统 | 火灾、交互助手 | P1 |
| 场景/UI | 菜单导航、游戏流程 | P2 |
| 可视化 | 精灵图渲染 | P2 |

---

## 3. Mock 策略

### 3.1 Phaser Mock

在 `src/__mocks__/phaser.ts` 创建共享 mock：

```typescript
import { vi } from "vitest";

export const createMockScene = () => ({
  add: {
    particles: vi.fn().mockReturnValue({
      stop: vi.fn(),
      start: vi.fn(),
      setConfig: vi.fn(),
      destroy: vi.fn(),
      setDepth: vi.fn(),
      setPosition: vi.fn(),
      emitting: false,
    }),
    rectangle: vi.fn().mockReturnValue({
      setDepth: vi.fn().mockReturnThis(),
      setVisible: vi.fn().mockReturnThis(),
      setOrigin: vi.fn().mockReturnThis(),
      destroy: vi.fn(),
    }),
    text: vi.fn().mockReturnValue({
      setDepth: vi.fn().mockReturnThis(),
      setOrigin: vi.fn().mockReturnThis(),
      setName: vi.fn().mockReturnThis(),
      setText: vi.fn().mockReturnThis(),
      destroy: vi.fn(),
    }),
    existing: vi.fn(),
  },
  physics: {
    add: {
      existing: vi.fn(),
      group: vi.fn().mockReturnValue({
        add: vi.fn(),
        remove: vi.fn(),
      }),
      staticGroup: vi.fn(),
    },
    world: {
      setBounds: vi.fn(),
    },
  },
  input: {
    keyboard: {
      addKeys: vi.fn().mockReturnValue({}),
      on: vi.fn(),
    },
    gamepad: {
      on: vi.fn(),
      gamepads: [],
    },
  },
  scale: { width: 800, height: 600 },
  cameras: {
    main: { width: 800, height: 600 },
  },
  time: {
    delayedCall: vi.fn(),
  },
});

export const MockPhaser = {
  Scene: class {},
  Physics: {
    Arcade: {
      Sprite: class {
        x = 0;
        y = 0;
        body = null;
        setDepth = vi.fn().mockReturnThis();
        setTint = vi.fn().mockReturnThis();
        clearTint = vi.fn().mockReturnThis();
        setVisible = vi.fn().mockReturnThis();
        setVelocity = vi.fn().mockReturnThis();
        setTexture = vi.fn().mockReturnThis();
        destroy = vi.fn();
      },
      StaticGroup: class {},
    },
  },
  Math: {
    Vector2: class {
      x: number;
      y: number;
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }
      set(x: number, y: number) {
        this.x = x;
        this.y = y;
        return this;
      }
      normalize() {
        return this;
      }
      angle() {
        return Math.atan2(this.y, this.x);
      }
      clone() {
        return new MockPhaser.Math.Vector2(this.x, this.y);
      }
      scale(s: number) {
        this.x *= s;
        this.y *= s;
        return this;
      }
    },
    Distance: {
      Between: (x1: number, y1: number, x2: number, y2: number) =>
        Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
    },
    RadToDeg: (rad: number) => rad * (180 / Math.PI),
  },
  Input: {
    Keyboard: {
      JustDown: vi.fn().mockReturnValue(false),
    },
  },
  GameObjects: {
    Particles: {
      ParticleEmitter: class {},
    },
    Rectangle: class {},
    Text: class {},
    Container: class {},
  },
};

export default MockPhaser;
```

### 3.2 Mock 使用模式

```typescript
import { describe, it, expect, beforeEach, vi } from "vitest";
import { createMockScene, MockPhaser } from "../../__mocks__/phaser";

vi.mock("phaser", () => ({ default: MockPhaser, ...MockPhaser }));

describe("MyComponent", () => {
  let mockScene: ReturnType<typeof createMockScene>;

  beforeEach(() => {
    mockScene = createMockScene();
    vi.clearAllMocks();
  });

  it("should work", () => {
    // 测试实现
  });
});
```

---

## 4. 测试规格

### 4.1 菜谱系统测试 (P0)

#### 4.1.1 FoodMatcher (`src/game/recipe/food-matcher.test.ts`)

```typescript
describe("FoodMatcher", () => {
  describe("matches", () => {
    it("烹饪状态和组件完全相同时应匹配成功");
    it("烹饪状态不同时应返回 false");
    it("组件数量不同时应返回 false");
    it("组件顺序不同但内容相同时应匹配成功");
  });

  describe("cookStatesEqual", () => {
    it("相同的烹饪状态数组应返回 true");
    it("长度不同时应返回 false");
    it("相同位置状态不同时应返回 false");
  });

  describe("componentsMatch", () => {
    it("应按类型和烹饪状态匹配食材");
    it("应递归匹配嵌套的 Food 组件");
    it("应使用贪婪算法进行无序匹配");
  });

  describe("ingredientMatches", () => {
    it("类型和烹饪状态相同时应匹配");
    it("食材类型不同时应失败");
    it("烹饪状态不同时应失败");
  });

  describe("calculateSimilarity", () => {
    it("完全匹配时应返回 100");
    it("部分烹饪状态匹配时应返回部分分数");
    it("烹饪状态权重 30%，组件权重 70%");
  });
});
```

#### 4.1.2 OrderManager (`src/game/recipe/order-manager.test.ts`)

```typescript
describe("OrderManager", () => {
  describe("generateOrder", () => {
    it("应创建带唯一 id 的订单");
    it("不应超过最大订单限制");
    it("未指定菜谱时应从池中随机选择");
    it("菜谱池为空时应返回 null");
  });

  describe("validateDelivery", () => {
    it("食物正确时应返回匹配的订单");
    it("食物不匹配时应返回 null");
    it("只应检查待处理的订单");
  });

  describe("completeOrder", () => {
    it("应将订单标记为已完成");
    it("应计算带时间奖励的得分");
    it("订单不存在时应返回 0");
  });

  describe("update", () => {
    it("应使超时订单过期");
    it("应根据剩余时间更新小费倍率");
    it("应返回新过期的订单列表");
  });

  describe("getRemainingTime", () => {
    it("应返回正确的剩余时间");
    it("已完成订单应返回 0");
  });
});
```

### 4.2 物品系统测试 (P0)

#### 4.2.1 Food (`src/game/item/food.test.ts`)

```typescript
describe("Food", () => {
  describe("组件管理", () => {
    it("应添加组件并更新位置");
    it("添加时应解除食材与玩家的持有关系");
    it("应返回正确的数量");
    it("应展平嵌套的 Food 结构");
  });

  describe("烹饪状态", () => {
    it("应添加烹饪状态并重置进度");
    it("应检查烹饪状态是否存在");
    it("应返回最后的烹饪状态");
  });

  describe("进度", () => {
    it("进度应限制在 0-100 之间");
    it("应显示/隐藏进度条");
  });

  describe("配料系统", () => {
    it("应识别基底食材");
    it("应验证配料是否可接受");
    it("应强制执行最大配料限制");
  });
});
```

#### 4.2.2 Ingredient (`src/game/item/ingredient/ingredient.test.ts`)

```typescript
describe("Ingredient", () => {
  describe("constructor", () => {
    it("应使用正确的类型初始化");
    it("提供基底配置时应正确应用");
  });

  describe("烹饪状态", () => {
    it("应添加烹饪状态并重置进度");
    it("过度烹饪时应更换纹理");
    it("应返回最后的烹饪状态");
  });

  describe("进度", () => {
    it("应正确获取和设置进度");
  });
});
```

### 4.3 工作站系统测试 (P1)

#### 4.3.1 Station 基类 (`src/game/stations/station.test.ts`)

```typescript
describe("Station", () => {
  describe("placeItem", () => {
    it("空闲时应放置物品");
    it("已有物品时应拒绝");
    it("canPlace 返回 false 时应拒绝");
    it("应将物品位置更新到工作站中心");
  });

  describe("update", () => {
    it("进度达到 100% 时应从 working 转换到 done");
    it("working 状态时应显示进度条");
    it("应处理着火状态");
  });

  describe("progress", () => {
    it("应委托给持有的物品处理进度");
  });
});
```

### 4.4 玩家系统测试 (P1)

#### 4.4.1 Player (`src/game/player/player.test.ts`)

```typescript
describe("Player", () => {
  describe("pick", () => {
    it("空手时应拾取物品");
    it("已持有物品时不应拾取");
    it("应解除物品与工作站的关联");
    it("应遵守工作站的 canPick 标志");
  });

  describe("putDownToFloor", () => {
    it("应将物品放置在玩家前方");
    it("应启用物品物理效果");
  });

  describe("dash", () => {
    it("应激活冲刺状态");
    it("应遵守冷却时间");
    it("持续时间结束后应自动停止");
  });

  describe("throw", () => {
    it("应向朝向方向投掷物品");
    it("应将物品设为飞行状态");
  });

  describe("getInteractTarget", () => {
    it("应找到范围内的工作站");
    it("应找到地面上的物品");
    it("工作站优先级应高于物品");
  });
});
```

### 4.5 场景/UI 测试 (P2)

#### 4.5.1 GameScene 菜单 (`src/game/scenes/game-scene.test.ts`)

```typescript
describe("GameScene", () => {
  describe("初始菜单", () => {
    it("首次加载时应显示「开始游戏」");
    it("初始时应隐藏「重新开始」按钮");
    it("点击「开始游戏」时应开始游戏");
    it("菜单可见时应暂停游戏逻辑");
  });

  describe("暂停菜单", () => {
    it("按 ESC 键时应切换菜单");
    it("暂停时应显示「继续游戏」和「重新开始」");
    it("点击「继续游戏」时应恢复游戏");
    it("点击「重新开始」时应重启场景");
    it("初始菜单状态下不应切换");
  });

  describe("菜单导航", () => {
    it("应支持方向键导航");
    it("应高亮选中的按钮");
    it("按 Enter 时应确认选择");
    it("应支持手柄导航");
  });
});
```

---

## 5. 可视化测试策略

### 5.1 精灵图验证方案

由于 Phaser 基于 canvas 渲染，直接进行可视化测试需要特殊设置。推荐方案：

#### 方案 A：快照测试（推荐用于 CI）

```typescript
describe("精灵图验证", () => {
  it("应加载所有必需的纹理", () => {
    const requiredTextures = [
      "player",
      "tomato",
      "plate",
      "pot",
      "overcooke",
      "particle_smoke",
    ];

    requiredTextures.forEach((key) => {
      expect(scene.textures.exists(key)).toBe(true);
    });
  });

  it("应创建具有正确初始属性的精灵", () => {
    const player = new Player(mockScene, 1, 100, 100, 0xff0000, keyMap);
    expect(player.x).toBe(100);
    expect(player.y).toBe(100);
    expect(player.texture.key).toBe("player");
  });
});
```

#### 方案 B：Playwright 集成（完整可视化测试）

```typescript
// playwright/visual.spec.ts
import { test, expect } from "@playwright/test";

test.describe("可视化测试", () => {
  test("游戏正确渲染", async ({ page }) => {
    await page.goto("http://localhost:8080");
    await page.waitForSelector("canvas");
    await expect(page).toHaveScreenshot("game-initial.png");
  });

  test("菜单正确渲染", async ({ page }) => {
    await page.goto("http://localhost:8080");
    await page.waitForSelector("canvas");
    await expect(page).toHaveScreenshot("menu.png");
  });
});
```

### 5.2 资源加载测试

```typescript
describe("资源加载", () => {
  it("应加载所有精灵表", async () => {
    const requiredAssets = [
      { key: "player", type: "image" },
      { key: "station_counter", type: "image" },
      { key: "particle_smoke", type: "image" },
    ];

    for (const asset of requiredAssets) {
      const exists = scene.textures.exists(asset.key);
      expect(exists).toBe(true);
    }
  });
});
```

---

## 6. 测试工具

### 6.1 工厂函数

创建 `src/__test-utils__/factories.ts`：

```typescript
import { FoodState } from "../game/item/ingredient/ingredient";
import { FoodDef, IngredientDef, Recipe, ingredientDef, foodDef } from "../game/recipe/types";

export function createIngredientDef(
  type: string,
  cookStates: FoodState[] = []
): IngredientDef {
  return ingredientDef(type, cookStates);
}

export function createFoodDef(
  components: (FoodDef | IngredientDef)[],
  cookStates: FoodState[] = []
): FoodDef {
  return foodDef(components, cookStates);
}

export function createRecipe(overrides: Partial<Recipe> = {}): Recipe {
  return {
    id: "test-recipe",
    category: "test",
    name: "Test Recipe",
    displayName: "Test Recipe",
    targetFood: createFoodDef([createIngredientDef("tomato", ["cut"])]),
    difficulty: 1,
    baseScore: 100,
    ...overrides,
  };
}

export function createMockStation(x = 100, y = 100, canFire = true) {
  return {
    x,
    y,
    canFire,
    canPick: true,
    workStatus: "idle" as const,
    item: null,
    placeItem: vi.fn().mockReturnValue(true),
    removeItem: vi.fn(),
  };
}

export function createMockPlayer(x = 100, y = 100) {
  return {
    x,
    y,
    heldItem: null,
    facing: { x: 1, y: 0, angle: () => 0 },
  };
}
```

### 6.2 自定义匹配器

创建 `src/__test-utils__/matchers.ts`：

```typescript
import { expect } from "vitest";
import Food from "../game/item/food";
import { FoodDef } from "../game/recipe/types";
import { FoodMatcher } from "../game/recipe/food-matcher";

expect.extend({
  toMatchRecipe(received: Food, expected: FoodDef) {
    const pass = FoodMatcher.matches(received, expected);
    return {
      pass,
      message: () =>
        pass
          ? `Expected food not to match recipe`
          : `Expected food to match recipe. Similarity: ${FoodMatcher.calculateSimilarity(received, expected)}%`,
    };
  },
});

declare module "vitest" {
  interface Assertion<T = any> {
    toMatchRecipe(expected: FoodDef): T;
  }
}
```

---

## 7. CI/CD 集成

### 7.1 GitHub Actions 工作流

创建 `.github/workflows/test.yml`：

```yaml
name: Test

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install

      - name: Run tests
        run: pnpm test

      - name: Upload coverage
        uses: codecov/codecov-action@v4
        if: always()
        with:
          files: ./coverage/lcov.info
```

### 7.2 Vitest 配置

更新 `vite.config.ts` 或创建 `vitest.config.ts`：

```typescript
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    globals: true,
    environment: "jsdom",
    include: ["src/**/*.test.ts"],
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html", "lcov"],
      include: ["src/game/**/*.ts"],
      exclude: [
        "src/game/**/*.test.ts",
        "src/__mocks__/**",
        "src/__test-utils__/**",
      ],
    },
    setupFiles: ["./src/__test-utils__/setup.ts"],
  },
});
```

### 7.3 测试启动文件

创建 `src/__test-utils__/setup.ts`：

```typescript
import { vi } from "vitest";

// 全局 mock
vi.mock("phaser", async () => {
  const { MockPhaser } = await import("../__mocks__/phaser");
  return { default: MockPhaser, ...MockPhaser };
});

// 每个测试之间重置 mock
beforeEach(() => {
  vi.clearAllMocks();
});
```

---

## 8. 实施路线图

### 第一阶段：基础设施（第 1 周）

- [ ] 创建共享 Phaser mock (`src/__mocks__/phaser.ts`)
- [ ] 创建测试工具和工厂函数
- [ ] 配置 Vitest 及覆盖率
- [ ] 实现 FoodMatcher 测试 (P0)
- [ ] 实现 OrderManager 测试 (P0)

### 第二阶段：核心系统（第 2 周）

- [ ] 实现 Food 测试
- [ ] 实现 Ingredient 测试
- [ ] 实现 Container 测试
- [ ] recipe 模块覆盖率达到 >80%

### 第三阶段：游戏系统（第 3 周）

- [ ] 实现 Station 测试
- [ ] 实现 Player 测试
- [ ] 实现 helper 测试（fire, interact）
- [ ] item/station 模块覆盖率达到 >70%

### 第四阶段：UI 与完善（第 4 周）

- [ ] 实现 GameScene 菜单测试
- [ ] 搭建可视化测试基础设施
- [ ] 添加 CI/CD 流水线
- [ ] 文档整理与清理

---

## 9. 覆盖率目标

| 模块 | 目标覆盖率 |
|------|-----------|
| recipe/ | 90% |
| item/ | 80% |
| stations/ | 70% |
| player/ | 70% |
| helper/ | 80% |
| scenes/ | 60% |
| **整体** | **75%** |

---

## 10. 参考资料

- [Vitest 文档](https://vitest.dev/)
- [Phaser 3 测试指南](https://phaser.io/tutorials)
- 现有测试：`src/game/item/fire-extinguisher.test.ts`、`src/game/helper/fire-helper.test.ts`
